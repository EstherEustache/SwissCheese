rm(list=ls())
library(fastDummies)
library(sampling)
library(bannerCommenter)
library(StratifiedSampling)

devtools::load_all("C:/Users/eustachee/switchdrive/Swiss cheese/subject_1/SwissCheese/R")
library(StratifiedSampling)






##------------------
##  Initialization
##------------------
N  <- 600
##---Gamma variables
g1 <- rgamma(N, shape = 7, rate = 0.2)
g2 <- rgamma(N, shape = 5, rate = 0.4)
g3 <- rgamma(N, shape = 9, rate = 0.1)
g4 <- rgamma(N, shape = 3, rate = 0.4)

##---Correlated variables from the gamma variables
V1 <- g1
V2 <- g1+g2
V3 <- g1-g3
V4 <- g1-g4
V5 <- (g1>35)*1
cor(cbind(V1,V2,V3,V4,V5))
##---Final data set
X <- cbind(V1,V2,V3,V4,V5)
J <- ncol(X)


#----pp: probabilités de réponse pour chaque variable
pp <- matrix(rep(0,N*J), c(N,J))
for(j in 1:J){
  if((j %% 2) != 0){
    pp[,j] <- 1 / (1 + exp(-0.105* X[, 1]))
  }else{
    pp[,j] <- 1 / (1 + exp(-(-0.15) * X[, 3]))
  }
}

generateNA <- function(X, pp, nr_min)
{
  #----Response indicator matrix: r
  nr <- 1
  r  <- matrix(rep(0,N*J), c(N,J))
  while(nr < nr_min) {
    for(j in 1:J){
      r[,j] <- UPpoisson(pp[,j])
    }
    nr <- sum(rowSums(r) == J)			# Number of respondent
  }
  #----Add NA to matrix X
  for(i in 1:ncol(X)){
    X[r[,i] == 0,i] <- NA
  }
  return(X)
}








##-----------------
## Dataset study
##-----------------

#--Correlations of numeric variables
cor <- cor(X)

#--------TABLE RESULTS-----------#
# library(dplyr)
# library(knitr)
# library(kableExtra)
# kable(cor, format = "latex",digits = 3,
#       booktabs = T, caption = paste0("Correlation of the 12 numeric variables. The population size is equal to ",
#                                      N,"."),
#       row.names = FALSE,escape = FALSE)%>%
#   add_header_above(c(" " = 1,"Correlation" = 12),escape = F) %>%
#   kable_styling(font_size = 9,latex_options="scale_down")


#--Skewness
# library(e1071)
# skew <- rep(0,J)
# for(i in 1:J){
#   skew[i] <- skewness(X[,i])
# }










##---------------
##  Simulations  
##---------------

col         <- colnames(X)
colnames(X) <- NULL

#----Number of simulations
nb_nr    <- 100   #---Number of random nonresponse
nb_imput <- 100   #---Number of random imputation   
nb_simu  <- nb_nr*nb_imput #---Total number of simulations



for(nr_i in 1:nb_nr){
  
  #----Matrix of results for each NA
  Estimate_simu <- matrix(rep(0,nb_imput*J*4*5), c(nb_imput,J*4*5))
  
  ##----------------------
  ##  Random nonresponse  
  ##----------------------
  
  X_NA <- generateNA(X, pp, nr_min = 50)
  
  
  for(imput_i in 1:nb_imput){
    set.seed(imput_i)
    
    ##--------------
    ##  Imputation  
    ##--------------
    
    #---Swiss cheese imputation
    SW   <- swissCheeseImput(X = X_NA, d = NULL, k = NULL, tol = 1e-2, max_iter = 50)
    X_SW <- SW$X
    
    #---Linear imputation
    LI   <- linearImput(X_NA, d = NULL, k = SW$k, tol = 1e-2, max_iter = 50)
    X_LI <- LI$X
    
    #---Random hotdeck imputation
    X_HD <- hotDeckImput(X_NA, k = SW$k)
    
    ##-----------
    ##  Results  
    ##-----------
    
    #--- Compute for each variable and each imputation method: total, 10-th and 90-th percentile, median, variance.
    tot     <- as.vector(colSums(X))
    tot_SW  <- as.vector(colSums(X_SW))
    tot_LI  <- as.vector(colSums(X_LI)) 
    tot_HD  <- as.vector(colSums(X_HD))
    
    P10     <- as.vector(apply(X,    2, quantile, probs = 0.1))
    P10_SW  <- apply(X_SW, 2, quantile, probs = 0.1)
    P10_LI  <- apply(X_LI, 2, quantile, probs = 0.1)
    P10_HD  <- apply(X_HD, 2, quantile, probs = 0.1)
    
    P90     <- apply(X,    2, quantile, probs = 0.9)
    P90_SW  <- apply(X_SW, 2, quantile, probs = 0.9)
    P90_LI  <- apply(X_LI, 2, quantile, probs = 0.9)
    P90_HD  <- apply(X_HD, 2, quantile, probs = 0.9)
    
    P50     <- apply(X,    2, quantile, probs = 0.5)
    P50_SW  <- apply(X_SW, 2, quantile, probs = 0.5)
    P50_LI  <- apply(X_LI, 2, quantile, probs = 0.5)
    P50_HD  <- apply(X_HD, 2, quantile, probs = 0.5)
    
    var     <- as.vector(apply(X,    2, function(x) var(x)))
    var_SW  <- as.vector(apply(X_SW, 2, function(x) var(x)))
    var_LI  <- as.vector(apply(X_LI, 2, function(x) var(x)))
    var_HD  <- as.vector(apply(X_HD, 2, function(x) var(x)))
    
    #---All results
    Estimate_simu[imput_i,] <- c(tot, tot_SW, tot_LI, tot_HD,
                                 P10, P10_SW, P10_LI, P10_HD, 
                                 P50, P50_SW, P50_LI, P50_HD,
                                 P90, P90_SW, P90_LI, P90_HD,
                                 var, var_SW, var_LI, var_HD)
  }
  path <- 'C:\\Users\\eustachee\\switchdrive\\Swiss cheese\\subject_1\\Simulation\\results\\'
  write.csv(Estimate_simu, file=paste0(path,"estimate_simu_",nr_i,".csv"))
}






##--------------------------
##  Bias, RMSE and variance
##--------------------------

resultSimu <- function(param) {
  #############
  theta       <- param[1,1:J] #----only one row because there are all equal (true value)
  
  #---Bias and RMSE of the estimate parameter of simulations (ex: total, P10, etc)
  #-------Relative bias
  B_SW <- colMeans(param[,(J+1):(2*J)])   - theta
  B_LI <- colMeans(param[,(2*J+1):(3*J)]) - theta
  B_HD <- colMeans(param[,(3*J+1):(4*J)]) - theta
  
  #-------RMSE
  RMSE_SW <- sqrt(colMeans((param[,(J+1):(2*J)]   - theta)^2)) 
  RMSE_LI <- sqrt(colMeans((param[,(2*J+1):(3*J)] - theta)^2)) 
  RMSE_HD <- sqrt(colMeans((param[,(3*J+1):(4*J)] - theta)^2))
  
  #############
  #---Variance of the estimate parameter according to the nonresponse
  vv           <- matrix(rep(0,nb_nr*J*4), ncol = J*4)
  vect_nr  <- rep(1:nb_nr, each = nb_imput)
  
  for (nr_i in  1:nb_nr) {
    #-------Mean for the imputation of nonresponse nr_i
    mean_i    <- colMeans(param[vect_nr == nr_i,])
    mean_ii   <- matrix(rep(mean_i, nb_imput), byrow=TRUE, ncol=J*4)
    
    #-------vv: Variances^2 of the parameter for the nb_nr nonresponse in rows
    vv[nr_i,] <- colSums((param[vect_nr == nr_i,] - mean_ii)^2) / (nb_imput-1)
  }
  
  #-------Variance
  var_nr_SW <- sqrt(colMeans(vv[,(J+1):(2*J)])) 
  var_nr_LI <- sqrt(colMeans(vv[,(2*J+1):(3*J)])) 
  var_nr_HD <- sqrt(colMeans(vv[,(3*J+1):(4*J)])) 
  
  #############
  #-------Final results
  B    <- round(rbind(B_SW = B_SW,        B_LI = B_LI,        B_HD = B_HD),        4)  
  RMSE <- round(rbind(RMSE_SW = RMSE_SW,  RMSE_LI = RMSE_LI,  RMSE_HD = RMSE_HD),  4)  
  V    <- round(rbind(Var_SW = var_nr_SW, Var_LI = var_nr_LI, Var_HD = var_nr_HD), 4)  
  
  return(list(B = B, RMSE = RMSE, V = V))
}




