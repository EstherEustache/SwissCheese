library(StratifiedSampling)
devtools::load_all("C:/Users/eustachee/switchdrive/Swiss cheese/subject_1/SwissCheese/R")
library(StratifiedSampling)
library(missForest)
##------------------
##  Initialization
##------------------
N  <- 600
##---Gamma variables
g1 <- rgamma(N, shape = 7, rate = 0.2)
g2 <- rgamma(N, shape = 5, rate = 0.4)
g3 <- rgamma(N, shape = 9, rate = 0.1)
g4 <- rgamma(N, shape = 3, rate = 0.4)
##---Correlated variables from the gamma variables
V1 <- g1
V2 <- g1+g2
V3 <- g1-g3
V4 <- g1-g4
V5 <- (g1>35)*1
cor(cbind(V1,V2,V3,V4,V5))
##---Final data set
X <- cbind(V1,V2,V3,V4,V5)
J <- ncol(X)
#----pp: probabilités de réponse pour chaque variable
pp <- matrix(rep(0,N*J), c(N,J))
for(j in 1:J){
if((j %% 2) != 0){
pp[,j] <- 1 / (1 + exp(-0.105* X[, 1]))
}else{
pp[,j] <- 1 / (1 + exp(-(-0.15) * X[, 3]))
}
}
generateNA <- function(X, pp, nr_min)
{
#----Response indicator matrix: r
nr <- 1
r  <- matrix(rep(0,N*J), c(N,J))
while(nr < nr_min) {
for(j in 1:J){
r[,j] <- UPpoisson(pp[,j])
}
nr <- sum(rowSums(r) == J)			# Number of respondent
}
#----Add NA to matrix X
for(i in 1:ncol(X)){
X[r[,i] == 0,i] <- NA
}
return(X)
}
col         <- colnames(X)
colnames(X) <- NULL
#----Number of simulations
nb_nr    <- 100   #---Number of random nonresponse
nb_imput <- 100   #---Number of random imputation
nb_simu  <- nb_nr*nb_imput #---Total number of simulations
for(nr_i in 1:nb_nr){
#----Matrix of results for each NA
Estimate_simu <- matrix(rep(0,nb_imput*10*4), c(nb_imput,10*4))
##----------------------
##  Random nonresponse
##----------------------
X_NA <- generateNA(X, pp, nr_min = 50)
for(imput_i in 1:nb_imput){
set.seed(imput_i)
##--------------
##  Imputation
##--------------
#---Swiss cheese imputation
SW   <- swissCheeseImput(X = X_NA, d = NULL, k = NULL, tol = 1e-2, max_iter = 50)
X_SW <- SW$X_new
#---Linear imputation
LI   <- linearImput(X_NA, d = NULL, k = SW$k, tol = 1e-2, max_iter = 50)
X_LI <- LI$X_new
#---Random hotdeck imputation
X_HD <- hotDeckImput(X_NA, k = SW$k)
##-----------
##  Results
##-----------
#--- Compute for each variable and each imputation method: the covariances.
cov     <-  c(cov(X)[-1,1],cov(X)[-c(1,2),2],cov(X)[-c(1,2,3),3],cov(X)[-c(1,2,3,4),4])
cov_SW  <-  c(cov(X_SW)[-1,1],cov(X_SW)[-c(1,2),2],cov(X_SW)[-c(1,2,3),3],cov(X_SW)[-c(1,2,3,4),4])
cov_LI  <-  c(cov(X_LI)[-1,1],cov(X_LI)[-c(1,2),2],cov(X_LI)[-c(1,2,3),3],cov(X_LI)[-c(1,2,3,4),4])
cov_HD  <-  c(cov(X_HD)[-1,1],cov(X_HD)[-c(1,2),2],cov(X_HD)[-c(1,2,3),3],cov(X_HD)[-c(1,2,3,4),4])
#---All results
Estimate_simu[imput_i,] <- c(cov, cov_SW, cov_LI, cov_HD)
print(imput_i)
}
path <- 'C:\\Users\\eustachee\\switchdrive\\Swiss cheese\\subject_1\\Simulation\\results\\'
write.csv(Estimate_simu, file=paste0(path,"estimate_simu_",nr_i,".csv"))
}
Xm <- rbind(c(NA,1,2,3), c(1,NA,2,2))
Xm
Xr <- rbind(c(2,3,4,1), c(1,3,2,1), c(1,2,3,1), c(2,3,2,3), c(1,1,2,1))
Xr
devtools::load_all("C:/Users/eustachee/switchdrive/Swiss cheese/subject_1/SwissCheese/R")
calibrateKnn(Xr, Xm)
indKnn(Xr, Xm)
knn <- indKnn(Xr, Xm)
calibrateKnn(Xr, Xm, knn = knn)
dr = NULL
dm = NULL
tol = 1e-2
max_iter = 2000
nr <- nrow(Xr)
nm <- nrow(Xm)
R  <- !is.na(Xm)
Xm[is.na(Xm)] <- 0
J  <- ncol(X)
#------sampling weights
if (is.null(dr)) { dr <- rep(1, nrow(Xr)) }
if (is.null(dm)) { dm <- rep(1, nrow(Xm)) }
#------Sums of variables of nonrespondents
tot_m   <- colSums(dm * Xm * R)
#------k
k     <- ncol(knn)
knn_k <- knn
psi   <- matrix(rep(1/k, nm*k), c(nm,k))
w_j   <- rep(0, nr)
w_tmp <- rep(0, nr)
#----Tolerance
error  <- rep(5, J) #condition of the while loop
it_2   <- 0
###----Main loop
while (max(error) > tol){
error_p <- error
it      <- 1
while(it < 10){
#----Calibration and update of the psi weigths
for (j in 1:J) {
##-----Only Sm units that responded to variable j
R1_j  <- which(R[,j]==1)
knn_j <- knn_k[R1_j,]
psi_j <- psi[R1_j,]
dm_j  <- dm[R1_j]
for(i in 1:nr){
w_j[i] <- sum((psi_j*dm_j)[knn_j == i])
}
##-----update psi_j for Sm units that have responded to variable j
lambda <- 0
c      <- 0
div    <- 1
V      <- var(Xr[,j])
while((div > 1e-10) & (c < 100)){
c      <- c+1
lambda <- lambda - (sum(w_j*Xr[,j]*exp(lambda*Xr[,j]))-tot_m[j])/sum(w_j*Xr[,j]*Xr[,j]*exp(lambda*Xr[,j]))
div    <- (sum(w_j*Xr[,j]*exp(Xr[,j]*lambda))-tot_m[j])/V
}
if(c < 100){
g <- exp(lambda*Xr[,j])
} else {
return(NULL)
}
g[is.nan(g)] <- rep(0, sum(is.nan(g)))
for (i in 1:nr) {
psi_j[knn_j == i] <- psi_j[knn_j == i]*g[i]
}
psi[R1_j,] <- psi_j
psi        <- t(apply(psi, 1, function(x) x/sum(x)))  #----normalization
}
it <- it+1
}
#----Normalization
psi <- t(apply(psi, 1, function(x) x/sum(x)))
for(j in 1:J){
#----Consider only respondents of variable j among Sm
R1_j     <- which(R[,j]==1)
knn_tmp  <- knn_k[R1_j,]
psi_tmp  <- psi[R1_j,]
dm_tmp   <- dm[R1_j]
for(i in 1:nr){
w_tmp[i] <- sum((psi_tmp*dm_tmp)[knn_tmp == i])
}
error[j] <- abs((Xr[,j] %*% w_tmp - tot_m[j]) / tot_m[j])
}
it_2 <- it_2+1
if(((max(error_p)-max(error))<1e-8) | (it_2 == max_iter)){
return(NULL)
}
}
error_p <- error
it      <- 1
j <- 1
##-----Only Sm units that responded to variable j
R1_j  <- which(R[,j]==1)
knn_j <- knn_k[R1_j,]
psi_j <- psi[R1_j,]
dm_j  <- dm[R1_j]
for(i in 1:nr){
w_j[i] <- sum((psi_j*dm_j)[knn_j == i])
}
##-----update psi_j for Sm units that have responded to variable j
lambda <- 0
c      <- 0
div    <- 1
V      <- var(Xr[,j])
while((div > 1e-10) & (c < 100)){
c      <- c+1
lambda <- lambda - (sum(w_j*Xr[,j]*exp(lambda*Xr[,j]))-tot_m[j])/sum(w_j*Xr[,j]*Xr[,j]*exp(lambda*Xr[,j]))
div    <- (sum(w_j*Xr[,j]*exp(Xr[,j]*lambda))-tot_m[j])/V
}
if(c < 100){
g <- exp(lambda*Xr[,j])
} else {
return(NULL)
}
g[is.nan(g)] <- rep(0, sum(is.nan(g)))
for (i in 1:nr) {
psi_j[knn_j == i] <- psi_j[knn_j == i]*g[i]
}
psi[R1_j,] <- psi_j
psi        <- t(apply(psi, 1, function(x) x/sum(x)))  #----normalization
psi   <- matrix(rep(1/k, nm*k), c(nm,k))
w_j   <- rep(0, nr)
w_tmp <- rep(0, nr)
#----Tolerance
error  <- rep(5, J) #condition of the while loop
it_2   <- 0
###----Main loop
while (max(error) > tol){
error_p <- error
it      <- 1
while(it < 10){
#----Calibration and update of the psi weigths
for (j in 1:J) {
##-----Only Sm units that responded to variable j
R1_j  <- which(R[,j]==1)
knn_j <- knn_k[R1_j,]
psi_j <- psi[R1_j,]
dm_j  <- dm[R1_j]
for(i in 1:nr){
w_j[i] <- sum((psi_j*dm_j)[knn_j == i])
}
##-----update psi_j for Sm units that have responded to variable j
lambda <- 0
c      <- 0
div    <- 1
V      <- var(Xr[,j])
while((div > 1e-10) & (c < 100)){
c      <- c+1
lambda <- lambda - (sum(w_j*Xr[,j]*exp(lambda*Xr[,j]))-tot_m[j])/sum(w_j*Xr[,j]*Xr[,j]*exp(lambda*Xr[,j]))
div    <- (sum(w_j*Xr[,j]*exp(Xr[,j]*lambda))-tot_m[j])/V
}
if(c < 100){
g <- exp(lambda*Xr[,j])
} else {
return(NULL)
}
g[is.nan(g)] <- rep(0, sum(is.nan(g)))
for (i in 1:nr) {
psi_j[knn_j == i] <- psi_j[knn_j == i]*g[i]
}
psi[R1_j,] <- psi_j
psi        <- t(apply(psi, 1, function(x) x/sum(x)))  #----normalization
}
it <- it+1
}
#----Calibration and update of the psi weigths
for (j in 1:J) {
##-----Only Sm units that responded to variable j
R1_j  <- which(R[,j]==1)
knn_j <- knn_k[R1_j,]
psi_j <- psi[R1_j,]
dm_j  <- dm[R1_j]
for(i in 1:nr){
w_j[i] <- sum((psi_j*dm_j)[knn_j == i])
}
##-----update psi_j for Sm units that have responded to variable j
lambda <- 0
c      <- 0
div    <- 1
V      <- var(Xr[,j])
while((div > 1e-10) & (c < 100)){
c      <- c+1
lambda <- lambda - (sum(w_j*Xr[,j]*exp(lambda*Xr[,j]))-tot_m[j])/sum(w_j*Xr[,j]*Xr[,j]*exp(lambda*Xr[,j]))
div    <- (sum(w_j*Xr[,j]*exp(Xr[,j]*lambda))-tot_m[j])/V
}
if(c < 100){
g <- exp(lambda*Xr[,j])
} else {
return(NULL)
}
g[is.nan(g)] <- rep(0, sum(is.nan(g)))
for (i in 1:nr) {
psi_j[knn_j == i] <- psi_j[knn_j == i]*g[i]
}
psi[R1_j,] <- psi_j
psi        <- t(apply(psi, 1, function(x) x/sum(x)))  #----normalization
}
for (j in 1:J) {
##-----Only Sm units that responded to variable j
R1_j  <- which(R[,j]==1)
knn_j <- knn_k[R1_j,]
psi_j <- psi[R1_j,]
dm_j  <- dm[R1_j]
for(i in 1:nr){
w_j[i] <- sum((psi_j*dm_j)[knn_j == i])
}
##-----update psi_j for Sm units that have responded to variable j
lambda <- 0
c      <- 0
div    <- 1
V      <- var(Xr[,j])
while((div > 1e-10) & (c < 100)){
c      <- c+1
lambda <- lambda - (sum(w_j*Xr[,j]*exp(lambda*Xr[,j]))-tot_m[j])/sum(w_j*Xr[,j]*Xr[,j]*exp(lambda*Xr[,j]))
div    <- (sum(w_j*Xr[,j]*exp(Xr[,j]*lambda))-tot_m[j])/V
}
if(c < 100){
g <- exp(lambda*Xr[,j])
} else {
return(NULL)
}
g[is.nan(g)] <- rep(0, sum(is.nan(g)))
for (i in 1:nr) {
psi_j[knn_j == i] <- psi_j[knn_j == i]*g[i]
}
psi[R1_j,] <- psi_j
psi        <- t(apply(psi, 1, function(x) x/sum(x)))  #----normalization
}
J
j
j = 5
R1_j  <- which(R[,j]==1)
knn_j <- knn_k[R1_j,]
psi_j <- psi[R1_j,]
dm_j  <- dm[R1_j]
R[,j]
R
Xm
X
is.na(Xm)
roxygen2::roxygenise()
setwd('"C:/Users/eustachee/switchdrive/Swiss cheese/subject_1/SwissCheese/R"')
setwd("C:/Users/eustachee/switchdrive/Swiss cheese/subject_1/SwissCheese/R")
roxygen2::roxygenise()
setwd("C:/Users/eustachee/switchdrive/Swiss cheese/subject_1/SwissCheese")
roxygen2::roxygenise()
devtools::load_all()
calibrateKnn(Xr, Xm, knn = knn)
for(i in 1:nr){
w_j[i] <- sum((psi_j*dm_j)[knn_j == i])
}
xr
Xr
Xm
Xr <- rbind(c(2,3,4,1), c(1,3,2,1), c(1,2,3,1), c(2,3,2,3), c(1,1,2,1))
Xm <- rbind(c(NA,1,2,3), c(1,NA,2,2))
calibrateKnn(Xr, Xm, knn = knn)
Xr
Xm
Xr <- rbind(c(2,3,4,1), c(1,3,2,1), c(1,2,3,1), c(2,3,2,3), c(1,1,2,1))
Xm <- rbind(c(NA,1,2,3), c(1,NA,2,NA))
calibrateKnn(Xr, Xm, knn = knn)
Xr <- rbind(c(0.8,0.3,0.4,0.1), c(0.1,0.3,0.2,0.1), c(0.1,0.2,0.3,0.1), c(0.2,0.3,0.2,0.3), c(0.1,0.1,0.2,0.1))
Xm <- rbind(c(NA,0.1,0.2,0.3), c(0.1,NA,0.2,NA))
calibrateKnn(Xr, Xm, knn = knn)
Xr <- rbind(c(0.8,0.3,0.4,0.1), c(0.1,0.3,0.2,0.1), c(0.1,0.2,0.3,0.1), c(0.2,0.3,0.2,0.3), c(0.1,0.1,0.2,0.1))
Xm <- rbind(c(NA,0.1,0.2,0.3), c(0.1,NA,0.2,NA))
calibrateKnn(Xr, Xm, knn = knn)
knn <- indKnn(Xr,Xm)
knn
calibrateKnn(Xr, Xm, knn = knn)
2/7
Xr <- rbind(c(0.8,0.3,0.4,0.1), c(0.1,0.3,0.2,0.1), c(0.1,0.2,0.3,0.1), c(0.2,0.3,0.2,0.3), c(0.1,0.1,0.2,0.1))
Xm <- rbind(c(NA,0.1,NA,0.3), c(0.1,NA,0.2,NA))
knn <- indKnn(Xr,Xm)
2/7
calibrateKnn(Xr, Xm, knn = knn)
is;na(Xm)
is.na(Xm)
Xr <- rbind(c(0.8,0.3,0.4,0.1), c(0.1,0.3,0.2,0.1), c(0.1,0.2,0.3,0.1), c(0.2,0.3,0.2,0.3), c(0.1,0.1,0.2,0.1))
Xm <- rbind(c(NA,0.1,NA,0.3), c(0.1,NA,0.2,NA))
knn <- indKnn(Xr,Xm)
calibrateKnn(xr,Xm)
calibrateKnn(Xr,Xm)
Xr <- rbind(c(0.8,0.3,0.4,0.1), c(0.1,0.3,0.2,0.1), c(0.1,0.2,0.3,0.1), c(0.2,0.3,0.2,0.3), c(0.1,0.1,0.2,0.1))
Xm <- rbind(c(NA,0.1,NA,0.3), c(0.1,NA,0.2,NA))
knn <- indKnn(Xr,Xm)
calibrateKnn(Xr,Xm, knn = knn)
Xr <- rbind(c(0.1,0.3,0.4,0.1), c(0.1,0.3,0.2,0.1), c(0.1,0.2,0.3,0.1), c(0.2,0.3,0.2,0.3), c(0.1,0.1,0.2,0.1))
Xm <- rbind(c(NA,0.1,NA,0.1), c(0.1,NA,0.2,NA))
knn <- indKnn(Xr,Xm)
calibrateKnn(Xr,Xm, knn = knn)
Xr  <- rbind(c(0.1,0.3,0.4,0.1), c(0.1,0.3,0.2,0.1), c(0.1,0.2,0.3,0.1), c(0.2,0.3,0.2,0.3), c(0.1,0.1,0.2,0.1))
Xm  <- rbind(c(NA,0.1,NA,0.1), c(0.1,NA,0.2,NA))
knn <- indKnn(Xr,Xm)
psi <- calibrateKnn(Xr,Xm, knn = knn)
cubeImput(Xr,Xm, knnknn, psi)
cubeImput(Xr,Xm, knn, psi)
if ((nrow(psi)!=nrow(knn))&(ncol(psi)!=ncol(knn))) { stop('PSI and knn matrix must have the same dimension.') }
##------------------
##  Initialization
##------------------
nm  <- nrow(Xm)
k   <- nrow(knn)
J   <- ncol(Xr)
EPS <- 1e-7
R   <- !is.na(Xm)
Xm[!R] <- 0
##---------------
##  Cube method
##---------------
X_pik      <- as.vector(psi)
X_strat    <- Xr[as.vector(knn),]
num_strat  <- rep(1:nm, each=k)
XX         <- matrix(X_pik, ncol=J, nrow=nm*k, byrow=FALSE) * R[num_strat,] * X_strat
pik_cube   <- balancedStratification(X = XX, pik = X_pik, stratum = num_strat, EPS)
X_pik
X_strat
num_strat
R
R[num_strat,]
X_strat
matrix(X_pik, ncol=J, nrow=nm*k, byrow=FALSE)
X_pik
J
nm*k
X_strat
length(X_pik)
psi
J
Xr
nm*k
psi
nm  <- nrow(Xm)
k   <- ncol(knn)
J   <- ncol(Xr)
EPS <- 1e-7
R   <- !is.na(Xm)
Xm[!R] <- 0
##---------------
##  Cube method
##---------------
X_pik      <- as.vector(psi)
X_strat    <- Xr[as.vector(knn),]
num_strat  <- rep(1:nm, each=k)
XX         <- matrix(X_pik, ncol=J, nrow=nm*k, byrow=FALSE) * R[num_strat,] * X_strat
pik_cube   <- balancedStratification(X = XX, pik = X_pik, stratum = num_strat, EPS)
XX
as.vector(knn)
knn
Xr  <- rbind(c(0.1,0.3,0.4,0.1), c(0.1,0.3,0.2,0.1), c(0.1,0.2,0.3,0.1), c(0.2,0.3,0.2,0.3), c(0.1,0.1,0.2,0.1))
Xm  <- rbind(c(NA,0.1,NA,0.1), c(0.1,NA,0.2,NA))
knn <- indKnn(Xr,Xm)
knn
XX
X_pik
length(pik)
length(X_pik)
dim(XX)
num_strat,
num_strat,
num_strat
EPS
pik_cube   <- balancedStratification(X = XX, pik = X_pik, stratum = num_strat, EPS)
1-1e-5
X_pik
sum(X_pik[1:5])
psi
rowSums(psi)
X_pik      <- as.vector(psi)
sum(X_pik[1:5])
##---------------
##  Cube method
##---------------
X_pik      <- as.vector(t(psi))
rowSums(psi)
if ((nrow(psi)!=nrow(knn))&(ncol(psi)!=ncol(knn))) { stop('PSI and knn matrix must have the same dimension.') }
##------------------
##  Initialization
##------------------
nm  <- nrow(Xm)
k   <- ncol(knn)
J   <- ncol(Xr)
EPS <- 1e-7
R   <- !is.na(Xm)
Xm[!R] <- 0
##---------------
##  Cube method
##---------------
X_pik      <- as.vector(t(psi))
X_strat    <- Xr[as.vector(knn),]
num_strat  <- rep(1:nm, each=k)
XX         <- matrix(X_pik, ncol=J, nrow=nm*k, byrow=FALSE) * R[num_strat,] * X_strat
pik_cube   <- balancedStratification(X = XX, pik = X_pik, stratum = num_strat, EPS)
devtools::load_all()
roxygen2::roxygenise()
devtools::load_all()
Xr  <- rbind(c(0.1,0.3,0.4,0.1), c(0.1,0.3,0.2,0.1), c(0.1,0.2,0.3,0.1), c(0.2,0.3,0.2,0.3), c(0.1,0.1,0.2,0.1))
Xm  <- rbind(c(NA,0.1,NA,0.1), c(0.1,NA,0.2,NA))
knn <- indKnn(Xr,Xm)
psi <- calibrateKnn(Xr,Xm, knn = knn)
cubeImput(Xr,Xm, knn, psi)
hotdeckImput(Xr,Xm, knn = knn)
hotDeckImput(Xr,Xm, knn = knn)
X <- rbind(Xr,Xm)
hotDeckImput(X)
Xr  <- rbind(c(0.1,0.3,0.4,0.1), c(0.1,0.3,0.2,0.1), c(0.1,0.2,0.3,0.1), c(0.2,0.3,0.2,0.3), c(0.1,0.1,0.2,0.1))
Xm  <- rbind(c(NA,0.1,NA,0.1), c(0.1,NA,0.2,NA))
X <- rbind(Xr,Xm)
hotDeckImput(X)
Xr  <- rbind(c(0.1,0.3,0.4,0.1), c(0.1,0.3,0.2,0.1), c(0.1,0.2,0.3,0.1), c(0.2,0.3,0.2,0.3), c(0.1,0.1,0.2,0.1))
Xm  <- rbind(c(NA,0.1,NA,0.1), c(0.1,NA,0.2,NA))
X <- rbind(Xr,Xm)
swissCheeseImput(X)
library(StratifiedSampling)
swissCheeseImput(X)
Xr  <- rbind(c(0.1,0.3,0.4,0.1), c(0.1,0.3,0.2,0.1), c(0.1,0.2,0.3,0.1), c(0.2,0.3,0.2,0.3), c(0.1,0.1,0.2,0.1))
Xm  <- rbind(c(NA,0.1,NA,0.1), c(0.1,NA,0.2,NA))
X <- rbind(Xr,Xm)
linearimput(X)
linearImput(X)
